\section*{Problem 3: Faint Analysis}

\begin{enumerate}
\item What is the set of elements that your analysis operates on? \\
Answer: The set of variables
\item What is the direction of your analysis? \\
Answer: Backward (exit to entry)
\item What is your transfer function? Be sure to clearly define any other sets that your transfer function uses (eg., GEN or KILL etc). \\
Answer: For this, we do an ``improved live variable analysis'' to detect variables that are ``surely live'' (which are used in assignments of other variables that are also ``surely live''). For this, we use the transfer function: $IN(B) = GEN_B \cup (OUT(B)-KILL_B)$. Here, $GEN_B$ and $KILL_B$ are same as those used in the live variable analysis, but the way we propagate and apply the transfer function changes a bit. During any point of the execution of data flow analysis, for a particular assignment instruction $s:= x = f(ops)$, where $x$ is the LHS and $f(ops)$ is the RHS, we use
\[
IN(s) = \left\{ 
\begin{array}{ll}
GEN_s \cup (OUT(s)-KILL_s) & \mbox{if } x \in OUT(s),\\
OUT(s) & \mbox{if } x \notin OUT(s).
\end{array}
\right.
\]

\item What is your meet operator? Give the equation that uses the meet operator. \\
Answer: The meet operator is union. $OUT(B) = \cup_{B': successor(B)} IN(B')$. This is because a variable that is ``surely live'' in any successor is a variable that is strongly live at the exit of a basic block. 
\item To what value do you initialize exit and/or entry? \\
Answer: $IN(exit) = \emptyset$ (nothing is live at exit).
\item To what values do you initialize the in or out sets? \\
Answer: For all other nodes $B$, $OUT(B) = \emptyset$.
\item Does the order that your analysis visits basic blocks matter? What order would you implement and why? \\
Answer: Yes, since we are doing a backward analysis, we want to visit all successors of a node before visiting the node itself. Thus, to make the analysis converge faster, we would implement postorder traversal of the nodes. 
\item Will your analysis converge? Why (in words, not a proof)? \\
Answer: Yes, the $IN$ and $OUT$ sets at each basic block are $n$-bit vectors (where $n$ is the number of variables). In each iteration at least one more bit is set in the $IN$ or $OUT$ set of at least one basic block (otherwise we stop the analysis), and no bit that is set is ever unset. So the analysis must converge in finitely many iterations.
\item Clearly describe in pseudo-code an algorithm that uses the result of your analysis to identify faint expressions.\\
Answer: Once we have the result of the analysis:\\
for each assignment instruction $s$ (visited in arbitrary order): Remove $s$ if $LHS(s) \notin OUT(s)$.  
\end{enumerate}