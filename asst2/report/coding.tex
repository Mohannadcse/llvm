\section{Iterative Data Flow Analysis Framework}

\subsection{Data Flow Framework}

We iterate over all functions in the module and for each function, we use helper functions in the
LLVM \texttt{Function} class, such as \texttt{getName()}, to obtain the required info.
We use the \texttt{size()} function in the \texttt{Instruction} class to compute the number of
instructions in all the basic blocks in the function.

\subsection{Source Code Listing}

The listing starts from the next page.

\includepdf[pages=-]{../ClassicalDataflow/dataflow.pdf}

\section{Liveness Analysis}

\subsection{Implementation}

We wrote a per-basic block pass that performs the required transformations. For each block, we keep
applying the 3 transformations within a \textbf{loop}, until the block is not modified after an entire iteration.
This is to ensure that the benefits of each optimization are relayed onto other optimizations and we
are not constrained by the order in which we apply the optimizations within a single iteration.
The transformations are described below:

\subsection{Source Code Listing}

The listing starts from the next page.

\includepdf[pages=-]{../ClassicalDataflow/liveness.pdf}

\subsection{Test Cases}

The test cases start from the next page.

\includepdf[pages=-]{../ClassicalDataflow/test-inputs/complex.pdf}

\subsection{Expected Results}

\begingroup
    \fontsize{6pt}{8pt}\selectfont
\begin{verbatim}
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                   { %argc }
                                                              %cmp = icmp slt i32 %argc, 2
                                             { %argc, %cmp }
                                                              br i1 %cmp, label %if.then, label %lor.lhs.false
                                                   { %argc }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                   { %argc }
                                                              %cmp1 = icmp sle i32 undef, 0
                                            { %argc, %cmp1 }
                                                              br i1 %cmp1, label %if.then, label %if.end
                                                   { %argc }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              br label %return
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                   { %argc }
                                                              %add = add nsw i32 %argc, 1
                                             { %argc, %add }
                                                              %mul = mul nsw i32 %argc, 5
                                             { %argc, %add }
                                                              %div = sdiv i32 %add, 2
                                       { %argc, %add, %div }
                                                              %cmp2 = icmp eq i32 %div, %argc
                                      { %argc, %add, %cmp2 }
                                                              br i1 %cmp2, label %if.then3, label %if.else
                                             { %argc, %add }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                   { %argc }
                                                              %rem = srem i32 %argc, 3
                                                   { %argc }
                                                              %rem4 = srem i32 %argc, 3
                                            { %argc, %rem4 }
                                                              %rem5 = srem i32 %rem4, 3
                                     { %argc, %rem4, %rem5 }
                                                              %mul6 = mul nsw i32 %rem4, 2
                                     { %argc, %rem4, %rem5 }
                                                              %div7 = sdiv i32 %rem5, 5
                                     { %argc, %rem4, %div7 }
                                                              br label %if.end10
                                     { %argc, %rem4, %div7 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                             { %argc, %add }
                                                              %div8 = sdiv i32 %add, 5
                                                   { %argc }
                                                              %rem9 = srem i32 %argc, 3
                                            { %argc, %rem9 }
                                                              br label %if.end10
                                            { %argc, %rem9 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                              %n.0 = phi i32 [ %rem4, %if.then3 ], [ %argc, %if.else ]
                                                              %m.0 = phi i32 [ %div7, %if.then3 ], [ %rem9, %if.else ]
                                       { %argc, %n.0, %m.0 }
                                                              %mul11 = mul nsw i32 %n.0, 2
                                       { %argc, %n.0, %m.0 }
                                                              %div12 = sdiv i32 %m.0, 5
                                       { %argc, %n.0, %m.0 }
                                                              %rem13 = srem i32 %n.0, 3
                                             { %argc, %m.0 }
                                                              %mul14 = mul nsw i32 %m.0, 2
                                                   { %argc }
                                                              br label %return
                                                   { %argc }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                              %retval.0 = phi i32 [ -1, %if.then ], [ %argc, %if.end10 ]
                                               { %retval.0 }
                                                              ret i32 %retval.0
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
\end{verbatim}
    \endgroup
  
\section{Available Expressions Analysis}

\subsection{Implementation}

We wrote a per-basic block pass that performs the required transformations. For each block, we keep
applying the 3 transformations within a \textbf{loop}, until the block is not modified after an entire iteration.
This is to ensure that the benefits of each optimization are relayed onto other optimizations and we
are not constrained by the order in which we apply the optimizations within a single iteration.
The transformations are described below:

\subsection{Source Code Listing}

The listing starts from the next page.

\includepdf[pages=-]{../ClassicalDataflow/available.pdf}

\subsection{Test Cases}

The test cases start from the next page.

\includepdf[pages=-]{../ClassicalDataflow/test-inputs/complex.pdf}

\subsection{Expected Results}

\begingroup
    \fontsize{6pt}{8pt}\selectfont
\begin{verbatim}
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              %cmp = icmp slt i32 %argc, 2
                                                         { }
                                                              br i1 %cmp, label %if.then, label %lor.lhs.false
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              %cmp1 = icmp sle i32 undef, 0
                                                         { }
                                                              br i1 %cmp1, label %if.then, label %if.end
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              br label %return
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              %add = add nsw i32 %argc, 1
                                               { %argc + 1 }
                                                              %mul = mul nsw i32 %argc, 5
                                    { %argc + 1, %argc * 5 }
                                                              %div = sdiv i32 %add, 2
                          { %argc + 1, %argc * 5, %add / 2 }
                                                              %cmp2 = icmp eq i32 %div, %argc
                          { %argc + 1, %argc * 5, %add / 2 }
                                                              br i1 %cmp2, label %if.then3, label %if.else
                          { %argc + 1, %argc * 5, %add / 2 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                          { %argc + 1, %argc * 5, %add / 2 }
                                                              %rem = srem i32 %argc, 3
               { %argc + 1, %argc * 5, %add / 2, %argc % 3 }
                                                              %rem4 = srem i32 %argc, 3
               { %argc + 1, %argc * 5, %add / 2, %argc % 3 }
                                                              %rem5 = srem i32 %rem4, 3
    { %argc + 1, %argc * 5, %add / 2, %argc % 3, %rem4 % 3 }
                                                              %mul6 = mul nsw i32 %rem4, 2
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %rem4 % 3, %rem4 * 2 }
                                                              %div7 = sdiv i32 %rem5, 5
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %rem4 % 3, %rem4 * 2, %rem5 / 5 }
                                                              br label %if.end10
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %rem4 % 3, %rem4 * 2, %rem5 / 5 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                          { %argc + 1, %argc * 5, %add / 2 }
                                                              %div8 = sdiv i32 %add, 5
                { %argc + 1, %argc * 5, %add / 2, %add / 5 }
                                                              %rem9 = srem i32 %argc, 3
     { %argc + 1, %argc * 5, %add / 2, %argc % 3, %add / 5 }
                                                              br label %if.end10
     { %argc + 1, %argc * 5, %add / 2, %argc % 3, %add / 5 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
               { %argc + 1, %argc * 5, %add / 2, %argc % 3 }
                                                              %n.0 = phi i32 [ %rem4, %if.then3 ], [ %argc, %if.else ]
               { %argc + 1, %argc * 5, %add / 2, %argc % 3 }
                                                              %m.0 = phi i32 [ %div7, %if.then3 ], [ %rem9, %if.else ]
               { %argc + 1, %argc * 5, %add / 2, %argc % 3 }
                                                              %mul11 = mul nsw i32 %n.0, 2
     { %argc + 1, %argc * 5, %add / 2, %argc % 3, %n.0 * 2 }
                                                              %div12 = sdiv i32 %m.0, 5
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %n.0 * 2, %m.0 / 5 }
                                                              %rem13 = srem i32 %n.0, 3
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %n.0 * 2, %m.0 / 5, %n.0 % 3 }
                                                              %mul14 = mul nsw i32 %m.0, 2
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %n.0 * 2, %m.0 / 5, %n.0 % 3, %m.0 * 2 }
                                                              br label %return
{ %argc + 1, %argc * 5, %add / 2, %argc % 3, %n.0 * 2, %m.0 / 5, %n.0 % 3, %m.0 * 2 }
//===--------------------------------------------------------------------------------------------------------------------------===//
//===--------------------------------------------------------------------------------------------------------------------------===//
                                                         { }
                                                              %retval.0 = phi i32 [ -1, %if.then ], [ %argc, %if.end10 ]
                                                         { }
                                                              ret i32 %retval.0
                                                         { }
//===--------------------------------------------------------------------------------------------------------------------------===//
\end{verbatim}
    \endgroup

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "asst1"
%%% End:
