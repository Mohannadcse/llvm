\section{LICM: Loop Invariant Code Motion}

\subsection{Dominance Information}

We use the following data flow equations to compute dominance information using the
data flow framework. \\

$\operatorname{Dom}(n_o) = \left \{ n_o \right \}$

$\operatorname{Dom}(n) = \left ( \bigcap_{p \in \text{preds}(n)}^{} \operatorname{Dom}(p) \right ) \bigcup^{} \left \{ n \right \}$,
where $n_o$ is the start node.

This is implemented in the ``DominanceAnalysis'' class. Function ``computeDom'' takes a loop as an argument, and runs DominanceAnalaysis for the basic blocks of the function containing the loop. Function ``dominates'' is a helper function that checks if node X dominates node Y. Function ``computeIdom'' computes immediate dominator relationship by using

$$
X \text{ idom } Y \text{ iff } X \text{ dom } Y \land \left(\not\exists Z \text { s.t. } X \text{ dom } Z\ \land\ Z \text{ dom } Y\right).
$$

Finally, class ``DomTree'' is used to construct a tree using the immediate dominator relationship. Traversing this tree in DFS order is helpful in finding invariant instructions in a single pass.

\subsection{Finding Invariant Instructions}

We use the following check to determine if an LLVM Instruction pointer I is invariant :

\texttt{isSafeToSpeculativelyExecute(I) \&\& !I->mayReadFromMemory() \&\& !isa<LandingPadInst>(I)}

A pure expression is loop invariant if its value does not change throughout the loop. 

The first check is required because the speculative instruction may not satisfy the required loop precondition across all loop iterations.

The second check is required because the contents of the memory may change across loop iterations.

\subsection{LICM Implementation}

For each loop, we first compute the domination tree, then detect the set of loop invariant instructions in a single pass by traversing the tree in the DFS order. We then perform code motion. As prescribed, we do not check if the instruction is in a block that dominates all loop exits. Further, our traversal of the tree in the DFS order (and moving the code in that order) preserves dependencies among the code moved. 

\subsection{Microbenchmarks}

\begin{table}[!ht]
\centering
\begin{tabular}{c|l|l}
  \toprule
  \textbf{Benchmark} & \textbf{Instruction Count} & \textbf{Transformed Instruction Count} \\
  \midrule
  licm-test-1 & 9887 & 9857 \\ 
  licm-test-2 & 797  & 405 \\
  licm-test-3 & 9406 & 9306 \\ 
  \bottomrule
\end{tabular}
\caption{Comparison between default bitcode's dynamic instruction count and transformed
  bitcode's dynamic instruction count.}
\end{table}  


\section{Dead Code Elimination}

\subsection{DCE Implementation}

To identify the set of faint instructions, we first identify the complementary set of \textbf{strongly live instructions}.
A strongly live instruction is a instruction that is either live by definition or is used in the assignment of another
strongly live instruction.
If a instruction is not strongly live, then it is a \textbf{faint instruction}.
That is, we can remove that instruction.

For any instruction $s$, let $x$ be variable in the LHS. Let $GEN_s$ be the set of variables in the RHS (like the live variable analysis) and
let $KILL_s = \{x\}$. We use the following transfer function, where we \textbf{alter data flow only if $x$ is strongly live}. That is :

\[
IN(s) = \left\{ 
\begin{array}{ll}
GEN_s \cup (OUT(s)-KILL_s) & \mbox{if } x \in OUT(s),\\
OUT(s) & \mbox{if } x \notin OUT(s).
\end{array}
\right.
\]

Now, during our data flow analysis, once we compute $OUT(B)$ for a basic block $B$, we iterate through the instructions of $B$ in the reverse order, and apply the transfer function given above. When we reach the first instruction of the block, its $IN$ will give us $IN(B)$. It seems that unlike the transfer function of live variable analysis, this transfer function is not composable (i.e., after composing over multiple instructions in the block, its final form is not of the same type $f(x) = GEN_x \cup (x-KILL_x)$) because the instructions on which we alter the data flow depends on $OUT(B)$ itself.\\  

We use the following check to determine if an LLVM Instruction pointer I is live.

\texttt{isa<TerminatorInst>() || isa<DbgInfoIntrinsic>(I) || \\  isa<LandingPadInst>(I) || I->mayHaveSideEffects()} or if I is used by any Instruction that is also live. 

We finally erase all the instructions that are faint.

\subsection{Microbenchmarks}

\begin{table}[!ht]
\centering
\begin{tabular}{c|l|l}
  \toprule
  \textbf{Benchmark} & \textbf{Instruction Count} & \textbf{Transformed Instruction Count} \\
  \midrule
  dce-test-1 & 7  & 6  \\ 
  dce-test-2 & 20 & 16 \\
  dce-test-3 & 4  & 2  \\
  dce-test-4 & 2  & 1  \\
  \bottomrule
\end{tabular}
\caption{Comparison between default bitcode's dynamic instruction count and transformed
  bitcode's dynamic instruction count.}
\end{table}  

\newpage

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "asst1"
%%% End:
